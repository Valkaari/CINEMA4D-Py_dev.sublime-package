{
		"scope" : "source.pythonAPI.cinema4D",
		"completions" : [
 				{"trigger": "c4d.utils.SendModelingCommand(command, list[, mode=MODIFY_ALL[, bc[, doc[, flags]]]])", "contents" : "SendModelingCommand(${1:command}, ${2:list} ${3:[, mode=4:MODIFY_ALL[, 5:bc[, 6:doc[, flags]}]]])"},
				{"trigger": "c4d.utils.GetAngle(v1, v2)", "contents" : "GetAngle(${1:v1}, ${2:v2})"},
				{"trigger": "c4d.utils.RangeMap(value, mininput, maxinput, minoutput, maxoutput, clampval[, curve])", "contents" : "RangeMap(${1:value}, ${2:mininput}, ${3:maxinput}, ${4:minoutput}, ${5:maxoutput}, ${6:clampval} ${7:[, curve]})"},
				{"trigger": "c4d.utils.Rad(d)", "contents" : "Rad(${1:d})"},
				{"trigger": "c4d.utils.Deg(r)", "contents" : "Deg(${1:r})"},
				{"trigger": "c4d.utils.MixVec(v1, v2, t)", "contents" : "MixVec(${1:v1}, ${2:v2}, ${3:t})"},
				{"trigger": "c4d.utils.MixNum(v1, v2, t)", "contents" : "MixNum(${1:v1}, ${2:v2}, ${3:t})"},
				{"trigger": "c4d.utils.Pulse(a, b, x)", "contents" : "Pulse(${1:a}, ${2:b}, ${3:x})"},
				{"trigger": "c4d.utils.Clamp(a, b, x)", "contents" : "Clamp(${1:a}, ${2:b}, ${3:x})"},
				{"trigger": "c4d.utils.ClampValue(x, a, b)", "contents" : "ClampValue(${1:x}, ${2:a}, ${3:b})"},
				{"trigger": "c4d.utils.Step(a, b)", "contents" : "Step(${1:a}, ${2:b})"},
				{"trigger": "c4d.utils.Smoothstep(a, b, x)", "contents" : "Smoothstep(${1:a}, ${2:b}, ${3:x})"},
				{"trigger": "c4d.utils.Boxstep(a, b, x)", "contents" : "Boxstep(${1:a}, ${2:b}, ${3:x})"},
				{"trigger": "c4d.utils.MatrixRotX(w)", "contents" : "MatrixRotX(${1:w})"},
				{"trigger": "c4d.utils.MatrixRotY(w)", "contents" : "MatrixRotY(${1:w})"},
				{"trigger": "c4d.utils.MatrixRotZ(w)", "contents" : "MatrixRotZ(${1:w})"},
				{"trigger": "c4d.utils.MatrixToRotAxis(m)", "contents" : "MatrixToRotAxis(${1:m})"},
				{"trigger": "c4d.utils.RotAxisToMatrix(v, w)", "contents" : "RotAxisToMatrix(${1:v}, ${2:w})"},
				{"trigger": "c4d.utils.GetOptimalAngle(hpb_old, hpb_new, rotation_order)", "contents" : "GetOptimalAngle(${1:hpb_old}, ${2:hpb_new}, ${3:rotation_order})"},
				{"trigger": "c4d.utils.PointLineDistance(p0, v, p)", "contents" : "PointLineDistance(${1:p0}, ${2:v}, ${3:p})"},
				{"trigger": "c4d.utils.ReflectRay(v, n)", "contents" : "ReflectRay(${1:v}, ${2:n})"},
				{"trigger": "c4d.utils.CalcSpline(x, knots)", "contents" : "CalcSpline(${1:x}, ${2:knots})"},
				{"trigger": "c4d.utils.CalcSplineV(x, knots)", "contents" : "CalcSplineV(${1:x}, ${2:knots})"},
				{"trigger": "c4d.utils.RGBToHSV(col)", "contents" : "RGBToHSV(${1:col})"},
				{"trigger": "c4d.utils.HSVToRGB(col)", "contents" : "HSVToRGB(${1:col})"},
				{"trigger": "c4d.utils.RGBToHSL(col)", "contents" : "RGBToHSL(${1:col})"},
				{"trigger": "c4d.utils.HSLtoRGB(col)", "contents" : "HSLtoRGB(${1:col})"},
				{"trigger": "c4d.utils.VectorEqual(v1, v2[, epsilon=0.01])", "contents" : "01])"},
				{"trigger": "c4d.utils.Bias(b, x)", "contents" : "Bias(${1:b}, ${2:x})"},
				{"trigger": "c4d.utils.FCut(a, b, c)", "contents" : "FCut(${1:a}, ${2:b}, ${3:c})"},
				{"trigger": "c4d.utils.CutColor(vec)", "contents" : "CutColor(${1:vec})"},
				{"trigger": "c4d.utils.Truncate(x)", "contents" : "Truncate(${1:x})"},
				{"trigger": "c4d.utils.VectorSum(vec)", "contents" : "VectorSum(${1:vec})"},
				{"trigger": "c4d.utils.VectorGray(vec)", "contents" : "VectorGray(${1:vec})"},
				{"trigger": "c4d.utils.VectorAngle(vec1, vec2)", "contents" : "VectorAngle(${1:vec1}, ${2:vec2})"},
				{"trigger": "c4d.utils.VectorMin(vec)", "contents" : "VectorMin(${1:vec})"},
				{"trigger": "c4d.utils.VectorMax(vec)", "contents" : "VectorMax(${1:vec})"},
				{"trigger": "c4d.utils.MatrixMove(vec)", "contents" : "MatrixMove(${1:vec})"},
				{"trigger": "c4d.utils.MatrixScale(s)", "contents" : "MatrixScale(${1:s})"},
				{"trigger": "c4d.utils.VectorToHPB(p)", "contents" : "VectorToHPB(${1:p})"},
				{"trigger": "c4d.utils.MatrixToHPB(m[, order=ROTATIONORDER_DEFAULT])", "contents" : "MatrixToHPB(${1:m} ${2:[, order=ROTATIONORDER_DEFAULT]})"},
				{"trigger": "c4d.utils.HPBToMatrix(hpb[, order=ROTATIONORDER_DEFAULT])", "contents" : "HPBToMatrix(${1:hpb} ${2:[, order=ROTATIONORDER_DEFAULT]})"},
				{"trigger": "c4d.utils.CalcLOD(val, lod, min, max)", "contents" : "CalcLOD(${1:val}, ${2:lod}, ${3:min}, ${4:max})"},
				{"trigger": "c4d.utils.CompareFloatTolerant(a, b)", "contents" : "CompareFloatTolerant(${1:a}, ${2:b})"},
				{"trigger": "c4d.utils.SinCos(w)", "contents" : "SinCos(${1:w})"},
				{"trigger": "c4d.utils.TransformColor(input, colortransformation)", "contents" : "TransformColor(${1:input}, ${2:colortransformation})"},
				{"trigger": "c4d.utils.CalculateTranslationScale(src, dst)", "contents" : "CalculateTranslationScale(${1:src}, ${2:dst})"},
				{"trigger": "c4d.utils.SphereLineIntersection(linePoint1, linePoint2, sphereCenter, sphereRadius)", "contents" : "SphereLineIntersection(${1:linePoint1}, ${2:linePoint2}, ${3:sphereCenter}, ${4:sphereRadius})"},
				{"trigger": "c4d.utils.CircleLineIntersection(linePoint1, linePoint2, circleCenter, circleRadius)", "contents" : "CircleLineIntersection(${1:linePoint1}, ${2:linePoint2}, ${3:circleCenter}, ${4:circleRadius})"},
  				{ "trigger": "____zzzzzdummy", "contents": "_____zzzzzdummy" } 
		]
}