{
		"scope" : "source.pythonAPI.cinema4D",
		"completions" : [
 				{"trigger": "c4d.utils.SendModelingCommand(command, list[, mode=MODELINGCOMMANDMODE_ALL][, bc=None][, doc=None][, flags=MODELINGCOMMANDFLAGS_0])", "contents" : "SendModelingCommand(${1:command}, ${2:list} ${3:[, mode=MODELINGCOMMANDMODE_ALL]} ${4:[, bc=None]} ${5:[, doc=None]} ${6:[, flags=MODELINGCOMMANDFLAGS_0]})"},
				{"trigger": "c4d.utils.DisjointMesh(op)", "contents" : "DisjointMesh(${1:op})"},
				{"trigger": "c4d.utils.FitCurve(padr, error)", "contents" : "FitCurve(${1:padr}, ${2:error})"},
				{"trigger": "c4d.utils.CheckDisplayFilter(op, filter)", "contents" : "CheckDisplayFilter(${1:op}, ${2:filter})"},
				{"trigger": "c4d.utils.CalculateVisiblePoints(bd, op)", "contents" : "CalculateVisiblePoints(${1:bd}, ${2:op})"},
				{"trigger": "c4d.utils.GenerateUVW(op, opmg, tp, texopmg[, view=None])", "contents" : "GenerateUVW(${1:op}, ${2:opmg}, ${3:tp}, ${4:texopmg} ${5:[, view=None]})"},
				{"trigger": "c4d.utils.GetBBox(pObj, mg)", "contents" : "GetBBox(${1:pObj}, ${2:mg})"},
				{"trigger": "c4d.utils.FormatNumber(val, format, fps[, bUnit=True])", "contents" : "FormatNumber(${1:val}, ${2:format}, ${3:fps} ${4:[, bUnit=True]})"},
				{"trigger": "c4d.utils.StringToNumber(text, format, fps)", "contents" : "StringToNumber(${1:text}, ${2:format}, ${3:fps})"},
				{"trigger": "c4d.utils.GetAngle(v1, v2)", "contents" : "GetAngle(${1:v1}, ${2:v2})"},
				{"trigger": "c4d.utils.RangeMap(value, mininput, maxinput, minoutput, maxoutput, clampval[, curve])", "contents" : "RangeMap(${1:value}, ${2:mininput}, ${3:maxinput}, ${4:minoutput}, ${5:maxoutput}, ${6:clampval} ${7:[, curve]})"},
				{"trigger": "c4d.utils.DegToRad(d)", "contents" : "DegToRad(${1:d})"},
				{"trigger": "c4d.utils.Rad(d)", "contents" : "Rad(${1:d})"},
				{"trigger": "c4d.utils.RadToDeg(r)", "contents" : "RadToDeg(${1:r})"},
				{"trigger": "c4d.utils.Deg(r)", "contents" : "Deg(${1:r})"},
				{"trigger": "c4d.utils.MixVec(v1, v2, t)", "contents" : "MixVec(${1:v1}, ${2:v2}, ${3:t})"},
				{"trigger": "c4d.utils.MixNum(v1, v2, t)", "contents" : "MixNum(${1:v1}, ${2:v2}, ${3:t})"},
				{"trigger": "c4d.utils.Pulse(a, b, x)", "contents" : "Pulse(${1:a}, ${2:b}, ${3:x})"},
				{"trigger": "c4d.utils.Clamp(a, b, x)", "contents" : "Clamp(${1:a}, ${2:b}, ${3:x})"},
				{"trigger": "c4d.utils.ClampValue(x, a, b)", "contents" : "ClampValue(${1:x}, ${2:a}, ${3:b})"},
				{"trigger": "c4d.utils.Step(a, b)", "contents" : "Step(${1:a}, ${2:b})"},
				{"trigger": "c4d.utils.Smoothstep(a, b, x)", "contents" : "Smoothstep(${1:a}, ${2:b}, ${3:x})"},
				{"trigger": "c4d.utils.Boxstep(a, b, x)", "contents" : "Boxstep(${1:a}, ${2:b}, ${3:x})"},
				{"trigger": "c4d.utils.MatrixRotX(w)", "contents" : "MatrixRotX(${1:w})"},
				{"trigger": "c4d.utils.MatrixRotY(w)", "contents" : "MatrixRotY(${1:w})"},
				{"trigger": "c4d.utils.MatrixRotZ(w)", "contents" : "MatrixRotZ(${1:w})"},
				{"trigger": "c4d.utils.QSlerp(q1, q2, alfa)", "contents" : "QSlerp(${1:q1}, ${2:q2}, ${3:alfa})"},
				{"trigger": "c4d.utils.QSquad(q0, q1, q2, q3, alfa)", "contents" : "QSquad(${1:q0}, ${2:q1}, ${3:q2}, ${4:q3}, ${5:alfa})"},
				{"trigger": "c4d.utils.QBlend(q1, q2, r)", "contents" : "QBlend(${1:q1}, ${2:q2}, ${3:r})"},
				{"trigger": "c4d.utils.QSpline(qn_m1, qn, qn_p1, qn_p2, t)", "contents" : "QSpline(${1:qn_m1}, ${2:qn}, ${3:qn_p1}, ${4:qn_p2}, ${5:t})"},
				{"trigger": "c4d.utils.QSmoothCubic(qn_m1, qn, qn_p1, t)", "contents" : "QSmoothCubic(${1:qn_m1}, ${2:qn}, ${3:qn_p1}, ${4:t})"},
				{"trigger": "c4d.utils.QNorm(q)", "contents" : "QNorm(${1:q})"},
				{"trigger": "c4d.utils.QMul(q1, q2)", "contents" : "QMul(${1:q1}, ${2:q2})"},
				{"trigger": "c4d.utils.QMulS(q, s)", "contents" : "QMulS(${1:q}, ${2:s})"},
				{"trigger": "c4d.utils.QAdd()", "contents" : "QAdd()"},
				{"trigger": "c4d.utils.QSub()", "contents" : "QSub()"},
				{"trigger": "c4d.utils.QInvert(q)", "contents" : "QInvert(${1:q})"},
				{"trigger": "c4d.utils.QDot(q1, q2)", "contents" : "QDot(${1:q1}, ${2:q2})"},
				{"trigger": "c4d.utils.QDeriv(q, w)", "contents" : "QDeriv(${1:q}, ${2:w})"},
				{"trigger": "c4d.utils.QLogN(q)", "contents" : "QLogN(${1:q})"},
				{"trigger": "c4d.utils.QExpQ(q)", "contents" : "QExpQ(${1:q})"},
				{"trigger": "c4d.utils.MatrixToRotAxis(m)", "contents" : "MatrixToRotAxis(${1:m})"},
				{"trigger": "c4d.utils.RotAxisToMatrix(v, w)", "contents" : "RotAxisToMatrix(${1:v}, ${2:w})"},
				{"trigger": "c4d.utils.GetOptimalAngle(hpb_old, hpb_new, rotation_order)", "contents" : "GetOptimalAngle(${1:hpb_old}, ${2:hpb_new}, ${3:rotation_order})"},
				{"trigger": "c4d.utils.PointLineDistance(p0, v, p)", "contents" : "PointLineDistance(${1:p0}, ${2:v}, ${3:p})"},
				{"trigger": "c4d.utils.ReflectRay(v, n)", "contents" : "ReflectRay(${1:v}, ${2:n})"},
				{"trigger": "c4d.utils.CalcSpline(x, knots)", "contents" : "CalcSpline(${1:x}, ${2:knots})"},
				{"trigger": "c4d.utils.CalcSplineV(x, knots)", "contents" : "CalcSplineV(${1:x}, ${2:knots})"},
				{"trigger": "c4d.utils.CalcSplinePoint(offset, type, closed, pcnt, padr[, tadr=None])", "contents" : "CalcSplinePoint(${1:offset}, ${2:type}, ${3:closed}, ${4:pcnt}, ${5:padr} ${6:[, tadr=None]})"},
				{"trigger": "c4d.utils.CalcSplineTangent(offset, type, closed, pcnt, padr[, tadr=None])", "contents" : "CalcSplineTangent(${1:offset}, ${2:type}, ${3:closed}, ${4:pcnt}, ${5:padr} ${6:[, tadr=None]})"},
				{"trigger": "c4d.utils.CalcSplineInsert(offset, type, closed, pcnt, padr[, tadr=None])", "contents" : "CalcSplineInsert(${1:offset}, ${2:type}, ${3:closed}, ${4:pcnt}, ${5:padr} ${6:[, tadr=None]})"},
				{"trigger": "c4d.utils.TransformTangent(newPos, planeNormal, position, tangent, tangentSide[, flags=c4d.TANGENTTRANSFORMFLAG_BREAK_SCALE])", "contents" : "TANGENTTRANSFORMFLAG_BREAK_SCALE])"},
				{"trigger": "c4d.utils.CalcSplineMovement(newPos, offset, type, splineMg, bd, planeNormal, closed, lockTangentAngle, lockTangentLength, breakTangents, pcnt, padr, tadr)", "contents" : "CalcSplineMovement(${1:newPos}, ${2:offset}, ${3:type}, ${4:splineMg}, ${5:bd}, ${6:planeNormal}, ${7:closed}, ${8:lockTangentAngle}, ${9:lockTangentLength}, 1${0:breakTangents}, 1${1:pcnt}, 1${2:padr}, 1${3:tadr})"},
				{"trigger": "c4d.utils.CalcSplineDefaultTangents(type, closed, pcnt, padr)", "contents" : "CalcSplineDefaultTangents(${1:type}, ${2:closed}, ${3:pcnt}, ${4:padr})"},
				{"trigger": "c4d.utils.BooleanSplines(initialSpline, booleanObjects, doc, bd, projectionAxis, booleanMode)", "contents" : "BooleanSplines(${1:initialSpline}, ${2:booleanObjects}, ${3:doc}, ${4:bd}, ${5:projectionAxis}, ${6:booleanMode})"},
				{"trigger": "c4d.utils.RGBToHSV(col)", "contents" : "RGBToHSV(${1:col})"},
				{"trigger": "c4d.utils.HSVToRGB(col)", "contents" : "HSVToRGB(${1:col})"},
				{"trigger": "c4d.utils.RGBToHSL(col)", "contents" : "RGBToHSL(${1:col})"},
				{"trigger": "c4d.utils.HSLtoRGB(col)", "contents" : "HSLtoRGB(${1:col})"},
				{"trigger": "c4d.utils.VectorEqual(v1, v2[, epsilon=0.01])", "contents" : "01])"},
				{"trigger": "c4d.utils.Bias(b, x)", "contents" : "Bias(${1:b}, ${2:x})"},
				{"trigger": "c4d.utils.FCut(a, b, c)", "contents" : "FCut(${1:a}, ${2:b}, ${3:c})"},
				{"trigger": "c4d.utils.CutColor(vec)", "contents" : "CutColor(${1:vec})"},
				{"trigger": "c4d.utils.Truncate(x)", "contents" : "Truncate(${1:x})"},
				{"trigger": "c4d.utils.VectorSum(vec)", "contents" : "VectorSum(${1:vec})"},
				{"trigger": "c4d.utils.VectorGray(vec)", "contents" : "VectorGray(${1:vec})"},
				{"trigger": "c4d.utils.VectorAngle(vec1, vec2)", "contents" : "VectorAngle(${1:vec1}, ${2:vec2})"},
				{"trigger": "c4d.utils.VectorMin(vec)", "contents" : "VectorMin(${1:vec})"},
				{"trigger": "c4d.utils.VectorMax(vec)", "contents" : "VectorMax(${1:vec})"},
				{"trigger": "c4d.utils.MatrixMove(vec)", "contents" : "MatrixMove(${1:vec})"},
				{"trigger": "c4d.utils.MatrixScale(s)", "contents" : "MatrixScale(${1:s})"},
				{"trigger": "c4d.utils.VectorToHPB(p)", "contents" : "VectorToHPB(${1:p})"},
				{"trigger": "c4d.utils.MatrixToHPB(m[, order=ROTATIONORDER_DEFAULT])", "contents" : "MatrixToHPB(${1:m} ${2:[, order=ROTATIONORDER_DEFAULT]})"},
				{"trigger": "c4d.utils.HPBToMatrix(hpb[, order=ROTATIONORDER_DEFAULT])", "contents" : "HPBToMatrix(${1:hpb} ${2:[, order=ROTATIONORDER_DEFAULT]})"},
				{"trigger": "c4d.utils.CalcLOD(val, lod, min, max)", "contents" : "CalcLOD(${1:val}, ${2:lod}, ${3:min}, ${4:max})"},
				{"trigger": "c4d.utils.CompareFloatTolerant(a, b)", "contents" : "CompareFloatTolerant(${1:a}, ${2:b})"},
				{"trigger": "c4d.utils.SinCos(w)", "contents" : "SinCos(${1:w})"},
				{"trigger": "c4d.utils.TransformColor(input, colortransformation)", "contents" : "TransformColor(${1:input}, ${2:colortransformation})"},
				{"trigger": "c4d.utils.CalculateTranslationScale(src, dst)", "contents" : "CalculateTranslationScale(${1:src}, ${2:dst})"},
				{"trigger": "c4d.utils.SphereLineIntersection(linePoint1, linePoint2, sphereCenter, sphereRadius)", "contents" : "SphereLineIntersection(${1:linePoint1}, ${2:linePoint2}, ${3:sphereCenter}, ${4:sphereRadius})"},
				{"trigger": "c4d.utils.CircleLineIntersection(linePoint1, linePoint2, circleCenter, circleRadius)", "contents" : "CircleLineIntersection(${1:linePoint1}, ${2:linePoint2}, ${3:circleCenter}, ${4:circleRadius})"},
				{"trigger": "c4d.utils.PointLineSegmentDistance(segmentPoint1, segmentPoint2, pos)", "contents" : "PointLineSegmentDistance(${1:segmentPoint1}, ${2:segmentPoint2}, ${3:pos})"},
				{"trigger": "c4d.utils.PointLineSegmentDistance2D(segmentPoint1, segmentPoint2, pos)", "contents" : "PointLineSegmentDistance2D(${1:segmentPoint1}, ${2:segmentPoint2}, ${3:pos})"},
				{"trigger": "c4d.utils.InitBakeTexture(doc, textags, texuvws, destuvws, bc[, th=None])", "contents" : "InitBakeTexture(${1:doc}, ${2:textags}, ${3:texuvws}, ${4:destuvws}, ${5:bc} ${6:[, th=None]})"},
				{"trigger": "c4d.utils.BakeTexture(doc, data, bmp, th, hook)", "contents" : "BakeTexture(${1:doc}, ${2:data}, ${3:bmp}, ${4:th}, ${5:hook})"},
  				{ "trigger": "____zdummy", "contents": "_____zdummy" } 
		]
}